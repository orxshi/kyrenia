import MeshElement as MeshElement
import Geometry as Geometry


class Mesh:
    def __init__(self, file_name):
        self.point = list()
        self.cell = list()
        self.bface = list()
        self.iface = list()
        self.read_gmsh(file_name)

    def read_gmsh(self, file_name):
        """
        Read mesh from a file generated by GMSH. Call in __init__.

        :param filename: name of file to read grid from. it comes from __init__. (default=None)
        :type filename: str
        :rtype: None
        """
        with open(file_name, 'r') as f:
            # read number of points
            for line in f:
                if '$Nodes' in line:
                    np = int(next(f))
                    break
            # read points
            for _ in range(np):
                a = []  # dummy list
                for token in next(f).split():  # split coordinates.
                    a.append(float(token))
                self.point.append(MeshElement.Point(a[1:], self))  # ignoring first char.
            # read number of elements
            for line in f:
                if '$Elements' in line:
                    ne = int(next(f))
                    break
            # read elements
            for i in range(ne):
                a = list()  # dummy list
                # a[0] refers to tag.
                # a[1] refers to geometric shape.
                # a[2] refers to number of tags.
                # according to number of tags:
                # a[3] refers to physical tag.
                # a[4] refers to geometric tag.
                # a[5] refers to number of partitions.
                # according to number of partitions:
                # a[...] refers to partitions.
                # the rest refers to vertices.
                for token in next(f).split():
                    a.append(int(token))
                if a[1] == 15:  # point
                    pass
                elif a[1] == 1:  # line
                    # read last two entries.
                    point = list()
                    point.append(self.point[a[-2] - 1])  # -1 because GMSH has base 1.
                    point.append(self.point[a[-1] - 1])  # -1 because GMSH has base 1.
                    wall = False  # so adjust physical number accordingly when creating GMSH file.
                    if a[3] == 1:
                        wall = True
                    self.bface.append(MeshElement.BoundaryFace(Geometry.Line([shape for shape in point]), point, wall, self))
                elif a[1] == 3:  # quad
                    # read last four entries.
                    point = list()
                    point.append(self.point[a[-4] - 1])  # -1 because GMSH has base 1.
                    point.append(self.point[a[-3] - 1])  # -1 because GMSH has base 1.
                    point.append(self.point[a[-2] - 1])  # -1 because GMSH has base 1.
                    point.append(self.point[a[-1] - 1])  # -1 because GMSH has base 1.
                    self.cell.append(MeshElement.Cell(Geometry.Quad([shape for shape in point]), point, self))

    def print_vtk(self, file_name):
        """
        Write mesh to a file in vtk format.

        :param file_name: name of file to write.
        :return: vtk file
        """

        f = open(file_name, 'w')

        f.write('# vtk DataFile Version 3.0\n')
        f.write('All in VTK format\n')
        f.write('ASCII\n')
        f.write('DATASET UNSTRUCTURED_GRID\n')
        f.write('POINTS %i float\n' % len(self.point))

        # write points
        for p in self.point:
            for i in p.shape.coor:
                f.write('%s ' % i)
            f.write('\n')

        # write cell list size
        celllistsize = 0
        for i in self.cell:
            celllistsize += i.shape.n_vertex + 1
        f.write('CELLS %i %i\n' % (len(self.cell), celllistsize))

        # write cell vertices
        for i in self.cell:
            f.write('%s ' % i.shape.n_vertex)
            for v in i.point:
                f.write('%s ' % self.point.index(v))
            f.write('\n')

        # write cell types
        f.write('CELL_TYPES %i\n' % len(self.cell))
        for cell in self.cell:
            if isinstance(cell.shape, Geometry.Quad):  # check if cell shape is quad.
                f.write('%i\n' % 9)


    def cell_to_cell_connect(self):
        # loop through cells.
        for cell in self.cell:
            faces = cell.set_face_vertices()
            # loop through points of faces.
            # note that 'faces' is not assigned to the cell yet.
            for face in faces:
                # loop though bfaces that the first point belongs to.
                for parent_bface in face.point[0].parent_bface:
                    # count number of parent bfaces other points of the face belongs to.
                    sig = 0
                    for point in face.point[1:]:  # do not consider the first face point.
                        sig += point.parent_bface.count(parent_bface.tag)
                    if sig == len(face.point) - 1:  # '-1' because we start from the second vertex to count matches.
                        cell.bface.append(bface)
                        bface.parent_cell.append(cell)
                        break  # looping though bfaces of the first face vertex.
                continue  # with the next face as we are done with the current one.

                for parent_cell in face.point[0].parent_cell:
                    if parent_cell == cell:


                        # count number of parent cells other points of the face belongs to.
                        sig = 0
                        for point in face.point[1:]:  # do not consider the first face point.
                            sig += point.parent_cell.count(parent_cell.tag)

                        if (std: :
                            find(cell[c].nei.begin(), cell[c].nei.end(), nei) != pt[n].cellTag.end())
                        {
                        // which
                        means
                        that
                        this
                        nei is already
                        checked
                        for this face.
                            continue; // with the next cell belonging.
                        }
                        }













